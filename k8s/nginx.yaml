apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
data:
  nginx.conf: |
    load_module modules/ngx_stream_js_module.so;

    events {
        worker_connections 1024;
    }

    stream {
        resolver kube-dns.kube-system.svc.cluster.local valid=5s;
        js_import fix_parser.js;
        js_set $backend_node fix_parser.getBackend;

        upstream shard_A {
            server node-backend-0.node-service:9876;
            server node-backend-1.node-service:9876 backup;
        }
        upstream shard_B {
            server node-backend-1.node-service:9876;
            server node-backend-2.node-service:9876 backup;
        }
        upstream fix_nodes {
            server node-backend-0.node-service:9876;
            server node-backend-1.node-service:9876;
            server node-backend-2.node-service:9876;
        }

        server {
            listen 9876;
            js_preread fix_parser.parseLogon;
            proxy_pass $backend_node;
        }
    }

    http {
        resolver kube-dns.kube-system.svc.cluster.local valid=5s;
        map $http_x_shard_id $backend_node {
            "0" "node-backend-0.node-service:3000";
            "1" "node-backend-1.node-service:3000";
            "2" "node-backend-2.node-service:3000";
            default "node-service:3000";
        }

        upstream nodes {
            ip_hash;
            server node-service:3000;
        }

        server {
            listen 80;

            location / {
                proxy_pass http://$backend_node;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }
        }
    }
  fix_parser.js: |
    function parseLogon(s) {
        s.on('upload', function (data, flags) {
            if (data.length > 0) {
                var str = data.toString();
                var match = str.match(/49=([^\x01]+)/);
                s.ctx = s.ctx || {};
                if (match) {
                    var sender = match[1];
                    s.log("Found SenderCompID: " + sender);
                    if (sender === "CLIENT_A") {
                        s.ctx.backend = "shard_A";
                    } else if (sender === "CLIENT_B") {
                        s.ctx.backend = "shard_B";
                    } else {
                        s.ctx.backend = "fix_nodes";
                    }
                }
                s.done();
            }
        });
    }
    function getBackend(s) {
        return (s.ctx && s.ctx.backend) ? s.ctx.backend : "fix_nodes";
    }
    export default { parseLogon, getBackend };
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-lb
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx-lb
  template:
    metadata:
      labels:
        app: nginx-lb
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
        - containerPort: 9876
        volumeMounts:
        - name: nginx-config-volume
          mountPath: /etc/nginx/nginx.conf
          subPath: nginx.conf
        - name: nginx-config-volume
          mountPath: /etc/nginx/fix_parser.js
          subPath: fix_parser.js
      volumes:
      - name: nginx-config-volume
        configMap:
          name: nginx-config
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  selector:
    app: nginx-lb
  ports:
    - name: http
      protocol: TCP
      port: 80
      targetPort: 80
    - name: fix
      protocol: TCP
      port: 9876
      targetPort: 9876
  type: LoadBalancer
